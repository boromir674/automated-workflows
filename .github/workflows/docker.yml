############################################
## Docker Build & Docker Push (Dockerhub) ##
##       Reusable Workflow                ##
############################################

# Build Docker image, authenticate with Dockerhub,
# and push image to Dockerhub public Registry.

## AUTONOMOUS DOCKER JOB ##
# Features:
# Configurable Behaviour, using Policies (see input.acceptance_policy):

#  1. Never run Docker build and publish to Dockerhub
#  aka: 'NO Docker', Docker Shutdown, 'No Admitance'
#  aka: guarantee that nothing is published

#  2. Always build and publish to Dockerhub
#   aka: Force Publish, Always Docker, 'Admit All'
#   aka: 'Free Admitance', 'No Entry Barrier', 'Free Entrance'

#  3. Run Docker build and publish to Dockerhub only if Tests passed (and ran!)
#   aka: Continous Integration / Continuous Deployment (CI/C Dpl)
#   aka: guranteed quality, everything published is tested
#   aka: 'required succesful evaluation', 'accept only a Pass'

#  4. Run Docker build and publish to Dockerhub, if Tests ran and passed, but also if Tests were skipped
#   aka: Continous Integration / Continuous Delivery (CI/C Dlv)
#   aka: CI/CD with Bypass Option
#   aka: 'accepted_when_Test_OFF', 'accept a Pass or a Skip'
#   aka: 'admit when test is off'


# Build from Dockerfile in repo root directory

# Authenticates to Dockerhub, using credentials stored in Github Secrets

# Logout from Dockerhub, regardless of whether the push succeeded or failed

# Steps:
#  1. Docker Build
#  2. Login to Dockerhub
#  3. Push to Dockerhub, noting success
#  4. Logout from Dockerhub
#  5. Finish Job, if Push succeded, else Fail Job

### Workflow INPUTS ###
# 1. Docker Image Slug
# 2. Docker Policy (number)
# 3. Docker Username (Secret)
# 4. Docker Password (Secret)


on:
  # Trigger when called from another workflow
  # Aka parent/caller workflow calls the child/"called" workflow
  workflow_call:
    inputs:
      image_slug:
        required: true
        type: string
      # Defaults to CI/CD if unknown policy or not given
      acceptance_policy:
        required: false
        type: number
      target_stage:
        required: false
        type: string
      image_tag:
        required: false
        type: string
    secrets:
      DOCKER_USER:
        required: true
      DOCKER_PASSWORD:
        required: true
    # Map the workflow outputs to job outputs
    outputs:
      image_ref:
        description: "Docker Image reference"
        value: ${{ jobs.docker_build.outputs.IMAGE_REF }}

jobs:
  ## AUTONOMOUS DOCKER BUILD and PUBLISH ON DOCKERHUB ##
  docker_build:

    ## Policy Logic ##
    # 2 bit state machine
    # 0 0 = 0: Never build, aka No Admitance, guarantee NO Dockerhub publish
    # 0 1 = 1: Always build and publish, aka Admit All, Force Docker
    # 1 0 = 2: CI/CD pure mode, aka Admit only if Pass, Require Pass, guarantee quality
    # 1 1 = 3: CI/CD with Bypass Opt, aka Admit Tested and when Test is OFF, Admit when Test OFF

    # always() is REQUIRED to implement any run if skipped, thing!
    if: always() && inputs.acceptance_policy != '0' && (
        inputs.acceptance_policy == '1' || (
        needs.*.result == 'success' && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') || (
        inputs.acceptance_policy == '3' && !contains(needs.*.result, 'failure') && (needs.*.result == 'skipped' || contains(needs.*.result, 'cancelled'))
      )))
    runs-on: ubuntu-latest
    env:
      IMAGE_SLUG: ${{ inputs.image_slug }}
      TARGET_STAGE: ${{ inputs.target_stage }}
      DOCKER_USER: ${{ secrets.DOCKER_USER }}
    steps:
    - uses: actions/checkout@v3
    - name: Build Docker Image from Dockerfile
      id: build_docker_image
      run: |
        
        # tag image with input tag if given
        IMAGE_TAG="${{ inputs.image_tag }}"
        # else use the git ref, which normally a branch or tag name
        # assuming workflow is enabled for branches and v* tags
        [ -z "$IMAGE_TAG" ] && IMAGE_TAG="${GITHUB_REF_NAME}"

        IMAGE_REF="${DOCKER_USER}/${IMAGE_SLUG}:${IMAGE_TAG}"

        echo " == Image Tag from Git Ref: $IMAGE_TAG == "
        echo " == Image Slug: $IMAGE_SLUG == "
        echo " == Image Ref: $IMAGE_REF == "

        # Set TARGET_FLAG to --target $TARGET_STAGE or an empty string
        TARGET_FLAG="--target $TARGET_STAGE"

        # Remove the --target flag if DOCKER_TARGET is empty
        [ -z "$TARGET_STAGE" ] && TARGET_FLAG=""

        # Build the Docker image with or without the target flag
        docker build "$TARGET_FLAG" -t "${IMAGE_REF}" .

        echo " -- DOCKER BUILD DONE --"
        echo " -- IMAGE: ${IMAGE_REF}"

        echo "IMAGE_REF=${IMAGE_REF}" >> $GITHUB_ENV
        echo "IMAGE_REF=${IMAGE_REF}" >> $GITHUB_OUTPUT

    - name: Login to Dockerhub, public Image Registry
      env:
        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      run: echo "${DOCKER_PASSWORD}" | docker login --username "${DOCKER_USER}" --password-stdin

    - name: Publish to DockerHub; Push Docker Image
      run: |
        push_success=1
        docker push "${IMAGE_REF}" || push_success=0
        if [ $push_success -eq 1 ]; then
          echo "Docker Image "${IMAGE_REF}" pushed to DockerHub!"
        else
          echo "[ERROR] Docker push failed!"
        fi
        echo "push_success=$push_success" >> $GITHUB_ENV

    - name: Logout from Dockerhub
      run: docker logout

    - name: Exit Job, with status code 0 if push was successful
      run: |
        if [ $push_success -eq 1 ]; then
          job_status=0
        else
          echo "[ERROR] Docker push failed!"
          job_status=1
        fi
        echo "Exiting with status code: $job_status"
        exit $job_status
    outputs:
      image_ref: ${{ steps.build_docker_image.outputs.IMAGE_REF }}
